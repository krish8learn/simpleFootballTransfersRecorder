// Code generated by sqlc. DO NOT EDIT.
// source: footballclub.sql

package DB

import (
	"context"
	"reflect"
	"testing"

	"github.com/krish8learn/simpleFootballTransfersRecorder/Util"
	"database/sql"
	"log"
)

func TestQueries_Createfootballclub(t *testing.T) {
	// type fields struct {
	// 	db DBTX
	// }
	type args struct {
		ctx context.Context
		arg CreatefootballclubParams
	}
	argument :=args{
		ctx: context.Background(),
		arg: CreatefootballclubParams{
			ClubName: Util.RandomfootballclubName(),
			CountryFc: Util.Randomcountryfc(),
			Balance: Util.Randombalance(),
		},
	}
	tests := []struct {
		name    string
		// fields  fields
		args    args
		want    Footballclub
		wantErr bool
	}{
		// TODO: Add test cases.
		{
			name: "TestCase1",
			args: argument,
			want: Footballclub{
				ClubName: argument.arg.ClubName,
				CountryFc:argument.arg.CountryFc,
				Balance: argument.arg.Balance,
			},
			wantErr :false,

		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// q := &Queries{
			// 	db: tt.fields.db,
			// }
			got, err := testQueries.Createfootballclub(tt.args.ctx, tt.args.arg)
			if (err != nil) != tt.wantErr {
				t.Errorf("Queries.Createfootballclub() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got.ClubName, tt.want.ClubName) && !reflect.DeepEqual(got.CountryFc, tt.want.CountryFc) && !reflect.DeepEqual(got.Balance, tt.want.Balance) {
				t.Errorf("Queries.Createfootballclub() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestQueries_Deletefootballclub(t *testing.T) {
	testCreateData, testCreateErr := testQueries.Createfootballclub(context.Background(), CreatefootballclubParams{
		ClubName: Util.RandomfootballclubName(),
		CountryFc: Util.Randomcountryfc(),
		Balance: Util.Randombalance(),
	})
	if testCreateErr != nil{
		t.Errorf("Cannot create Data in DB for testing")
	}

	type fields struct {
		db DBTX
	}
	//trying to create seperate connection for testing
	conn, connerr := sql.Open(dbDriver, dbConnectionDetails)
	if connerr != nil {
		log.Fatalln("Connection Failed, Error--> ", connerr)
	}
	
	var dbExec *fields
	dbExec = func (db DBTX) *fields {
		return &fields{db: db}
	}(conn)
	type args struct {
		ctx      context.Context
		clubName string
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
		{
			name: "TestCase1",
			fields: *dbExec,
			args: args{
				ctx: context.Background(),
				clubName:testCreateData.ClubName ,
			},
			wantErr : false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			q := &Queries{
				db: tt.fields.db,
			}
			if err := q.Deletefootballclub(tt.args.ctx, tt.args.clubName); (err != nil) != tt.wantErr {
				t.Errorf("Queries.Deletefootballclub() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestQueries_Getfootballclub(t *testing.T) {
	testCreateData, testCreateErr := testQueries.Createfootballclub(context.Background(), CreatefootballclubParams{
		ClubName: Util.RandomfootballclubName(),
		CountryFc: Util.Randomcountryfc(),
		Balance: Util.Randombalance(),
	})
	if testCreateErr != nil{
		t.Errorf("Cannot create Data in DB for testing")
	}
	// type fields struct {
	// 	db DBTX
	// }
	type args struct {
		ctx  context.Context
		fcID int32
	}
	tests := []struct {
		name    string
		// fields  fields
		args    args
		want    Footballclub
		wantErr bool
	}{
		// TODO: Add test cases.
		
		{
			name:"TestCase1",
			args: args{
				ctx: context.Background(),
				fcID: testCreateData.FcID,
			},
			want: Footballclub{
				FcID: testCreateData.FcID,
				ClubName: testCreateData.ClubName,
				CountryFc: testCreateData.CountryFc,
				Balance: testCreateData.Balance,
				CreatedAt: testCreateData.CreatedAt,
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// q := &Queries{
			// 	db: tt.fields.db,
			// }
			got, err := testQueries.Getfootballclub(tt.args.ctx, tt.args.fcID)
			if (err != nil) != tt.wantErr {
				t.Errorf("Queries.Getfootballclub() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Queries.Getfootballclub() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestQueries_Listfootballclub(t *testing.T) {
	// type fields struct {
	// 	db DBTX
	// }
	//we will create test data in footballclub table
	var listfootballclub []Footballclub
	
	for i:=0; i<8; i++{
		
		testCreateData, testCreateErr := testQueries.Createfootballclub(context.Background(), CreatefootballclubParams{
			ClubName: Util.RandomfootballclubName(),
			CountryFc: Util.Randomcountryfc(),
			Balance: Util.Randombalance(),
		})
		if testCreateErr != nil{
			t.Errorf("Cannot create Data in DB for testing")
		}
		// if i == 0{
		// 	firstFcId = testCreateData.FcID
		// }
		listfootballclub = append(listfootballclub, testCreateData)

	}
	type args struct {
		ctx context.Context
		arg ListfootballclubParams
	}
	tests := []struct {
		name    string
		// fields  fields
		args    args
		want    []Footballclub
		wantErr bool
	}{
		// TODO: Add test cases.
		{
			name: "TestCase1",
			args: args{
				ctx: context.Background(),
				arg: ListfootballclubParams{
					Limit: 8,
					Offset: 0,
				},
			},
			want: listfootballclub,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// q := &Queries{
			// 	db: tt.fields.db,
			// }
			got, err := testQueries.Listfootballclub(tt.args.ctx, tt.args.arg,)
			if (err != nil) != tt.wantErr {
				t.Errorf("Queries.Listfootballclub() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Queries.Listfootballclub() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestQueries_UpdatefootballclubBalance(t *testing.T) {
	// type fields struct {
	// 	db DBTX
	// }
	testCreateData, testCreateErr := testQueries.Createfootballclub(context.Background(), CreatefootballclubParams{
		ClubName: Util.RandomfootballclubName(),
		CountryFc: Util.Randomcountryfc(),
		Balance: Util.Randombalance(),
	})
	if testCreateErr != nil{
		t.Errorf("Cannot create Data in DB for testing")
	}
	type args struct {
		ctx context.Context
		arg UpdatefootballclubBalanceParams
	}
	tests := []struct {
		name    string
		// fields  fields
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
		{
			name: "TestCase1",
			args: args{
				ctx: context.Background(),
				arg: UpdatefootballclubBalanceParams{
					FcID: testCreateData.FcID,
					Balance: Util.Randombalance(),
				},
			},
			wantErr : false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// q := &Queries{
			// 	db: tt.fields.db,
			// }
			if err := testQueries.UpdatefootballclubBalance(tt.args.ctx, tt.args.arg); (err != nil) != tt.wantErr {
				t.Errorf("Queries.UpdatefootballclubBalance() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
